<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot 实现各种参数校验</title>
      <link href="/2022/02/08/SpringBoot-%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2022/02/08/SpringBoot-%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>之前也写过一篇关于Spring Validation使用的文章，不过自我感觉还是浮于表面，本次打算彻底搞懂Spring Validation。本文会详细介绍Spring Validation各种场景下的最佳实践及其实现原理，死磕到底！</p><blockquote><p>项目源码：<a href="https://github.com/chentianming11/spring-validation">https://github.com/chentianming11/spring-validation</a></p></blockquote><h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><p>Java API规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。</p><p>Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。接下来，我们以spring-boot项目为例，介绍Spring Validation的使用。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>如果spring-boot版本小于2.3.x，spring-boot-starter-web会自动传入hibernate-validator依赖。如果spring-boot版本大于2.3.x，则需要手动引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于web服务来说，为防止非法参数对业务造成影响，在Controller层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：</p><ul><li>POST、PUT请求，使用requestBody传递参数；</li><li>GET请求，使用requestParam/PathVariable传递参数。</li></ul><p>下面我们简单介绍下requestBody和requestParam/PathVariable的参数校验实战！</p><h3 id="requestBody参数校验"><a href="#requestBody参数校验" class="headerlink" title="requestBody参数校验"></a>requestBody参数校验</h3><p>POST、PUT请求一般会使用requestBody传递参数，这种情况下，后端使用DTO对象进行接收。只要给DTO对象加上@Validated注解就能实现自动参数校验。比如，有一个保存User的接口，要求userName长度是2-10，account和password字段长度是6-20。</p><p>如果校验失败，会抛出MethodArgumentNotValidException异常，Spring默认会将其转为400（Bad Request）请求。</p><blockquote><p>DTO表示数据传输对象（Data Transfer Object），用于服务器和客户端之间交互传输使用的。在spring-web项目中可以表示用于接收请求参数的Bean对象。</p></blockquote><p>在DTO字段上声明约束注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法参数上声明校验注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，使用@Valid和@Validated都可以。</p><h3 id="requestParam-PathVariable参数校验"><a href="#requestParam-PathVariable参数校验" class="headerlink" title="requestParam/PathVariable参数校验"></a>requestParam/PathVariable参数校验</h3><p>GET请求一般会使用requestParam/PathVariable传参。如果参数比较多(比如超过6个)，还是推荐使用DTO对象接收。</p><p>否则，推荐将一个个参数平铺到方法入参中。在这种情况下，必须在Controller类上标注@Validated注解，并在入参上声明约束注解(如@Min等)。如果校验失败，会抛出ConstraintViolationException异常。</p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路径变量</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">detail</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="meta">@Min(10000000000000000L)</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">        UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">        userDTO.setUserId(userId);</span><br><span class="line">        userDTO.setAccount(<span class="string">&quot;11111111111111111&quot;</span>);</span><br><span class="line">        userDTO.setUserName(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">        userDTO.setAccount(<span class="string">&quot;11111111111111111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询参数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;getByAccount&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getByAccount</span><span class="params">(<span class="meta">@Length(min = 6, max = 20)</span> <span class="meta">@NotNull</span> String  account)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">        UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">        userDTO.setUserId(<span class="number">10000000000000003L</span>);</span><br><span class="line">        userDTO.setAccount(account);</span><br><span class="line">        userDTO.setUserName(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">        userDTO.setAccount(<span class="string">&quot;11111111111111111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>前面说过，如果校验失败，会抛出MethodArgumentNotValidException或者ConstraintViolationException异常。在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。</p><p>比如我们系统要求无论发送什么异常，http的状态码必须返回200，由业务码去区分系统的异常情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">        BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;校验失败:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            sb.append(fieldError.getField()).append(<span class="string">&quot;：&quot;</span>).append(fieldError.getDefaultMessage()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String msg = sb.toString();</span><br><span class="line">       <span class="keyword">return</span> Result.fail(BusinessCode.参数校验失败, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ConstraintViolationException.class&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(BusinessCode.参数校验失败, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-进阶使用"><a href="#2-进阶使用" class="headerlink" title="2. 进阶使用"></a>2. 进阶使用</h2><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>在实际项目中，可能多个方法需要使用同一个DTO类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在DTO类的字段上加约束注解无法解决这个问题。因此，spring-validation支持了分组校验的功能，专门用来解决这类问题。</p><p>还是上面的例子，比如保存User的时候，UserId是可空的，但是更新User的时候，UserId的值必须&gt;=10000000000000000L；其它字段的校验规则在两种情况下一样。这个时候使用分组校验的代码示例如下：</p><p>约束注解上声明适用的分组信息groups</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 10000000000000000L, groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Save</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Validated注解上指定校验分组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Save.class)</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Update.class)</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h3><p>前面的示例中，DTO类里面的字段都是基本数据类型和String类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。</p><p>比如，上面保存User信息的时候同时还带有Job信息。需要注意的是，此时DTO类的对应字段必须标记@Valid注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 10000000000000000L, groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Job job;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Min(value = 1, groups = Update.class)</span></span><br><span class="line">        <span class="keyword">private</span> Long jobId;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String jobName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Save</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如<code>List&lt;Job&gt;</code>字段会对这个list里面的每一个Job对象都进行校验</p><h3 id="集合校验"><a href="#集合校验" class="headerlink" title="集合校验"></a>集合校验</h3><p>如果请求体直接传递了json数组给后台，并希望对数组中的每一项都进行参数校验。此时，如果我们直接使用java.util.Collection下的list或者set来接收数据，参数校验并不会生效！我们可以使用自定义list集合来接收参数：</p><p>包装List类型，并声明@Valid注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delegate</span> <span class="comment">// @Delegate是lombok注解</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 一定要加@Valid注解</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要记得重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Delegate注解受lombok版本限制，1.18.6以上版本可支持。如果校验不通过，会抛出NotReadablePropertyException，同样可以使用统一异常进行处理。</p><p>比如，我们需要一次性保存多个User对象，Controller层的方法可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/saveList&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveList</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Save.class)</span> ValidationList&lt;UserDTO&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h3><p>业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。</p><p>自定义spring validation非常简单，假设我们自定义加密id（由数字或者a-f的字母组成，32-256长度）校验，主要分为两步：</p><p>自定义约束注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;EncryptIdValidator.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EncryptId &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认错误消息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;加密id格式错误&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载</span></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现ConstraintValidator接口编写约束校验器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptIdValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">EncryptId</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN = Pattern.compile(<span class="string">&quot;^[a-f\\d]&#123;32,256&#125;$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不为null才进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Matcher matcher = PATTERN.matcher(value);</span><br><span class="line">            <span class="keyword">return</span> matcher.find();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以使用@EncryptId进行参数校验了！</p><h3 id="编程式校验"><a href="#编程式校验" class="headerlink" title="编程式校验"></a>编程式校验</h3><p>上面的示例都是基于注解来实现自动校验的，在某些情况下，我们可能希望以编程方式调用验证。这个时候可以注入javax.validation.Validator对象，然后再调用其api。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> javax.validation.Validator globalValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编程式校验</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveWithCodingValidate&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveWithCodingValidate</span><span class="params">(<span class="meta">@RequestBody</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;UserDTO&gt;&gt; validate = globalValidator.validate(userDTO, UserDTO.Save.class);</span><br><span class="line">    <span class="comment">// 如果校验通过，validate为空；否则，validate包含未校验通过项</span></span><br><span class="line">    <span class="keyword">if</span> (validate.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;UserDTO&gt; userDTOConstraintViolation : validate) &#123;</span><br><span class="line">            <span class="comment">// 校验失败，做其它逻辑</span></span><br><span class="line">            System.out.println(userDTOConstraintViolation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速失败-Fail-Fast"><a href="#快速失败-Fail-Fast" class="headerlink" title="快速失败(Fail Fast)"></a>快速失败(Fail Fast)</h3><p>Spring Validation默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启Fali Fast模式，一旦校验失败就立即返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Validator <span class="title">validator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)</span><br><span class="line">            .configure()</span><br><span class="line">            <span class="comment">// 快速失败模式</span></span><br><span class="line">            .failFast(<span class="keyword">true</span>)</span><br><span class="line">            .buildValidatorFactory();</span><br><span class="line">    <span class="keyword">return</span> validatorFactory.getValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid和-Validated区别"><a href="#Valid和-Validated区别" class="headerlink" title="@Valid和@Validated区别"></a>@Valid和@Validated区别</h3><p>如图</br><br><img src="https://s2.loli.net/2022/02/08/RqmnVMUwPefiLbO.jpg" alt="646.jpg"></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><h3 id="requestBody参数校验实现原理"><a href="#requestBody参数校验实现原理" class="headerlink" title="requestBody参数校验实现原理"></a>requestBody参数校验实现原理</h3><p>在spring-mvc中，RequestResponseBodyMethodProcessor是用于解析@RequestBody标注的参数以及处理@ResponseBody标注方法的返回值的。显然，执行参数校验的逻辑肯定就在解析参数的方法resolveArgument()中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        parameter = parameter.nestedIfOptional();</span><br><span class="line">        <span class="comment">//将请求数据封装到DTO对象中</span></span><br><span class="line">        Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">        String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">            <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 执行数据校验</span></span><br><span class="line">                validateIfApplicable(binder, parameter);</span><br><span class="line">                <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，resolveArgument()调用了validateIfApplicable()进行参数校验。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取参数注解，比如@RequestBody、@Valid、@Validated</span></span><br><span class="line">    Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">        <span class="comment">// 先尝试获取@Validated注解</span></span><br><span class="line">        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);</span><br><span class="line">        <span class="comment">//如果直接标注了@Validated，那么直接开启校验。</span></span><br><span class="line">        <span class="comment">//如果没有，那么判断参数前是否有Valid起头的注解。</span></span><br><span class="line">        <span class="keyword">if</span> (validatedAnn != <span class="keyword">null</span> || ann.annotationType().getSimpleName().startsWith(<span class="string">&quot;Valid&quot;</span>)) &#123;</span><br><span class="line">            Object hints = (validatedAnn != <span class="keyword">null</span> ? validatedAnn.value() : AnnotationUtils.getValue(ann));</span><br><span class="line">            Object[] validationHints = (hints <span class="keyword">instanceof</span> Object[] ? (Object[]) hints : <span class="keyword">new</span> Object[] &#123;hints&#125;);</span><br><span class="line">            <span class="comment">//执行校验</span></span><br><span class="line">            binder.validate(validationHints);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，大家应该能明白为什么这种场景下@Validated、@Valid两个注解可以混用。我们接下来继续看WebDataBinder.validate()实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors, Object... validationHints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.targetValidator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processConstraintViolations(</span><br><span class="line">            <span class="comment">//此处调用Hibernate Validator执行真正的校验</span></span><br><span class="line">            <span class="keyword">this</span>.targetValidator.validate(target, asValidationGroups(validationHints)), errors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终发现底层最终还是调用了Hibernate Validator进行真正的校验处理。</p><h3 id="方法级别的参数校验实现原理"><a href="#方法级别的参数校验实现原理" class="headerlink" title="方法级别的参数校验实现原理"></a>方法级别的参数校验实现原理</h3><p>上面提到的将参数一个个平铺到方法参数中，然后在每个参数前面声明约束注解的校验方式，就是方法级别的参数校验。</p><p>实际上，这种方式可用于任何Spring Bean的方法上，比如Controller/Service等。其底层实现原理就是AOP，具体来说是通过MethodValidationPostProcessor动态注册AOP切面，然后使用MethodValidationInterceptor对切点方法织入增强。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationPostProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryAwareAdvisingPostProcessorimplements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为所有`@Validated`标注的Bean创建切面</span></span><br><span class="line">        Pointcut pointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">this</span>.validatedAnnotationType, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//创建Advisor进行增强</span></span><br><span class="line">        <span class="keyword">this</span>.advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(<span class="keyword">this</span>.validator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Advice，本质就是一个方法拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Advice <span class="title">createMethodValidationAdvice</span><span class="params">(<span class="meta">@Nullable</span> Validator validator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (validator != <span class="keyword">null</span> ? <span class="keyword">new</span> MethodValidationInterceptor(validator) : <span class="keyword">new</span> MethodValidationInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看一下MethodValidationInterceptor：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//无需增强的方法，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isFactoryBeanMetadataMethod(invocation.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取分组信息</span></span><br><span class="line">        Class&lt;?&gt;[] groups = determineValidationGroups(invocation);</span><br><span class="line">        ExecutableValidator execVal = <span class="keyword">this</span>.validator.forExecutables();</span><br><span class="line">        Method methodToValidate = invocation.getMethod();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//方法入参校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">            result = execVal.validateParameters(</span><br><span class="line">                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有异常直接抛出</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//真正的方法调用</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line">        <span class="comment">//对返回值做校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);</span><br><span class="line">        <span class="comment">//有异常直接抛出</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，不管是requestBody参数校验还是方法级别的校验，最终都是调用Hibernate Validator执行校验，Spring Validation只是做了一层封装。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图解i++和++i的区别</title>
      <link href="/2022/02/08/%E5%9B%BE%E8%A7%A3i++%E5%92%8C++i%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/08/%E5%9B%BE%E8%A7%A3i++%E5%92%8C++i%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="先看一段代码："><a href="#先看一段代码：" class="headerlink" title="先看一段代码："></a>先看一段代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = i++;</span><br><span class="line">sout(<span class="string">&quot;a的值是:&quot;</span>+i);</span><br><span class="line">sout(<span class="string">&quot;i的值是:&quot;</span>+i);</span><br></pre></td></tr></table></figure><p>最终的编译之后的核心字节码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L0</span><br><span class="line"> BITPUSH <span class="number">0</span>  <span class="comment">//将常量0压入操作栈</span></span><br><span class="line"> ISTORE_1  <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_1中</span></span><br><span class="line"></span><br><span class="line">L1</span><br><span class="line"> ILOAD_1   <span class="comment">//从局部变量表的第一个slot槽中，取出该值，压入操作栈顶</span></span><br><span class="line"> IINC <span class="number">0</span>,<span class="number">1</span>    <span class="comment">//直接将slot槽中的值自增（+1）操作，注意此时是与当前栈无关的 </span></span><br><span class="line"> ISTORE_2   <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_2中</span></span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"> ILOAD_2    <span class="comment">//从局部变量表的第二个slot槽中，取出该值，压入操作栈顶</span></span><br><span class="line">  IRETURN  <span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><p>这里有两个注意点:</p><ul><li><code>IINC</code> 的自增操作,并未影响当前的栈顶元素,并且 slot_1 中的元素自增完成后,已经由0变成了1</li><li><code>ISTORE_2</code> 弹出的栈顶元素值依旧是0,并未改变</li></ul><p>最终的输出的结果为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a的值是: <span class="number">0</span> </span><br><span class="line">i的值是: <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我这里画了一个图来帮助大家理解</br><br><img src="https://s2.loli.net/2022/02/08/G8akw4rI1OLYoW5.jpg" alt="640.jpg"><br><img src="https://s2.loli.net/2022/02/08/sBjAKxuQwJkYno5.jpg" alt="641.jpg"><br><img src="https://s2.loli.net/2022/02/08/IGDwFnWOciTkjaA.jpg" alt="642.jpg"><br><img src="https://s2.loli.net/2022/02/08/ceWxiqp6BR1bQwP.jpg" alt="643.jpg"><br><img src="https://s2.loli.net/2022/02/08/QANFcGlL2KspJif.jpg" alt="644.jpg"><br><img src="https://s2.loli.net/2022/02/08/stnOl6pqVJhY4ig.jpg" alt="645.jpg"> </p><p>再来看看++i</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = ++i;</span><br><span class="line">sout(<span class="string">&quot;a的值是:&quot;</span>+i);</span><br><span class="line">sout(<span class="string">&quot;i的值是:&quot;</span>+i);</span><br></pre></td></tr></table></figure><p>对于++i 来说,对应的字节码如下，先自增再入栈，那么结果就很清晰了</p><p>最终的核心编译之后的字节码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L0</span><br><span class="line"> BITPUSH <span class="number">0</span>  <span class="comment">//将常量0压入操作栈</span></span><br><span class="line"> ISTORE_1  <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_1中</span></span><br><span class="line"></span><br><span class="line">L1</span><br><span class="line"> IINC <span class="number">0</span>,<span class="number">1</span>    <span class="comment">//直接将slot槽中的值自增（+1）操作</span></span><br><span class="line"> ILOAD_1   <span class="comment">//从局部变量表的第一个slot槽中，取出该值(该值此时已经自增过了)，压入操作栈顶</span></span><br><span class="line"> ISTORE_2   <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_2中</span></span><br><span class="line"></span><br><span class="line">L3</span><br><span class="line"> ILOAD_2    <span class="comment">//从局部变量表的第二个slot槽中，取出该值，压入操作栈顶</span></span><br><span class="line"> IRETURN  <span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><p>最终的输出的结果为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a的值是: <span class="number">1</span> </span><br><span class="line">i的值是: <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>i++</code> 和 ++i 在理论上的区别是 ：</p><ul><li><code>i++</code>：是先把i拿出来使用，然后再+1；</li><li><code>++i</code> ：是先把i+1，然后再拿出来使用；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>idea的这些功能你都用会了吗？</title>
      <link href="/2022/02/05/idea%E7%9A%84%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%A0%E9%83%BD%E7%94%A8%E4%BC%9A%E4%BA%86%E5%90%97/"/>
      <url>/2022/02/05/idea%E7%9A%84%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%A0%E9%83%BD%E7%94%A8%E4%BC%9A%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近正好也没什么可忙的，就回过头来鼓捣过去的知识点，到Servlet部分时，以前学习的时候硬是把从上到下的继承关系和接口实现记得乱七八糟。</p><p>这次利用了 IDEA 的 diagram，结果一目了然，也是好用到炸裂，就此分享。</p><h2 id="查看图形形式的继承链"><a href="#查看图形形式的继承链" class="headerlink" title="查看图形形式的继承链"></a><strong>查看图形形式的继承链</strong></h2><p>在你想查看的类的标签页内，点击右键，选择 Diagrams，其中有 show 和 show … Popup，只是前者新建在标签页内，后者以浮窗的形式展示：</p><p><img src="https://s2.loli.net/2022/02/05/8mYAcuTbraZvDXM.png"></p><p>实际上，你也可以从左边的项目目录树中，对你想查看的类点击右键，同样选择Diagrams，效果是一样的：</p><p><img src="https://s2.loli.net/2022/02/05/5ce8mZyWRqsKBfG.png"></p><p>然后你就会得到如下图所示的继承关系图形，以自定义的Servlet为例：</p><p><img src="https://s2.loli.net/2022/02/05/iIMkEoUy65aSBdN.png"></p><h2 id="优化继承链图形，想我所想"><a href="#优化继承链图形，想我所想" class="headerlink" title="优化继承链图形，想我所想"></a><strong>优化继承链图形，想我所想</strong></h2><h3 id="去掉不关心的类"><a href="#去掉不关心的类" class="headerlink" title="去掉不关心的类"></a><strong>去掉不关心的类</strong></h3><p>得到的继承关系图形，有些并不是我们想去了解的，比如上图的Object和Serializable，我们只想关心Servlet重要的那几个继承关系，怎么办？</p><p>简单，删掉。点击选择你想要删除的类，然后直接使用键盘上的delete键就行了。清理其他类的关系后图形如下：</p><p><img src="https://s2.loli.net/2022/02/05/YBestXDa2hTpoIz.png"></p><h3 id="展示类的详细信息"><a href="#展示类的详细信息" class="headerlink" title="展示类的详细信息"></a><strong>展示类的详细信息</strong></h3><p>有人说，诶，这怎么够呢，那继承下来的那些方法我也想看啊？简单，IDEA通通满足你。</p><p>在页面点击右键，选择 show categories，根据需要可以展开类中的属性、方法、构造方法等等。当然，第二种方法也可以直接使用上面的工具栏：</p><p><img src="https://s2.loli.net/2022/02/05/ORxvbnC63gDyFTc.png"></p><p>然后你就会得到：</p><p><img src="https://s2.loli.net/2022/02/05/yksvfK1jJE6L3Sw.png"></p><p>什么，方法里你还想筛选，比如说想看protected权限及以上范围的？简单，右键选择 Change Visibility Level，根据需要调整即可。</p><p><img src="https://s2.loli.net/2022/02/05/4nJ6yDRT9brl1vX.png"></p><p>什么，你嫌图形太小你看不清楚？IDEA也可以满足你，按住键盘的Alt，竟然出现了放大镜，惊不惊喜，意不意外？</p><p><img src="https://s2.loli.net/2022/02/05/gdkwA19ePfyt4ID.png"></p><h3 id="加入其他类到关系中来"><a href="#加入其他类到关系中来" class="headerlink" title="加入其他类到关系中来"></a><strong>加入其他类到关系中来</strong></h3><p>当我们还需要查看其他类和当前类是否有继承上的关系的时候，我们可以选择加其加入到当前的继承关系图形中来。</p><p>在页面点击右键，选择 Add Class to Diagram，然后输入你想加入的类就可以了：</p><p><img src="https://s2.loli.net/2022/02/05/vRPVdYz5wQBZ4X2.png"></p><p>例如我们添加了一个Student类，如下图所示。好吧，并没有任何箭头，看来它和当前这几个类以及接口并没有发生什么不可描述的关系：</p><p><img src="https://s2.loli.net/2022/02/05/u37kXepHIdNMmKz.png"></p><h3 id="查看具体代码"><a href="#查看具体代码" class="headerlink" title="查看具体代码"></a><strong>查看具体代码</strong></h3><p>如果你想查看某个类中，比如某个方法的具体源码，当然，不可能给你展现在图形上了，不然屏幕还不得撑炸？</p><p>但是可以利用图形，或者配合IDEA的structure方便快捷地进入某个类的源码进行查看。</p><p>双击某个类后，你就可以在其下的方法列表中游走，对于你想查看的方法，选中后点击右键，选择 Jump to Source：</p><p><img src="https://s2.loli.net/2022/02/05/RwFvDNzMlk5sjaL.png"></p><p><img src="https://s2.loli.net/2022/02/05/y5vTQGe9wOHVm7p.png"></p><p>在进入某个类后，如果还想快速地查看该类的其他方法，还可以利用IDEA提供的structure功能：</p><p><img src="https://s2.loli.net/2022/02/05/hKFIHs7ngdYjcu5.png"></p><p>选择左侧栏的structure之后，如上图左侧会展示该类中的所有方法，点击哪个方法，页面内容就会跳转到该方法部分去。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>用上面提到的的IDEA这些功能，学习和查看类关系，了解诸如主流框架源码之类的东西，可以说是非常舒服了。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
