<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBootCli示例</title>
      <link href="/2022/02/09/SpringBootCLI%E7%A4%BA%E4%BE%8B/"/>
      <url>/2022/02/09/SpringBootCLI%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>Spring boot CLI是运行spring boot命令的命令行界面。Spring提供了用于创建、运行和测试spring boot应用程序的spring命令。</p><blockquote><p>Spring boot CLI应用程序使用groovy语言，通过这种方式，我们用最少的代码行创建我们的应用程序并启动它。</p></blockquote><p>使用groovy的Spring boot CLI具有以下特点。</p><p>\1. Spring boot CLI应用程序使用groovy。我们在应用程序中创建groovy文件，为此我们不需要提供groovy的任何JAR依赖。Spring boot会自己配置groovy的JAR依赖项。</p><p>\2. 在编写groovy文件时，我们不需要写导入语句，直到需要为止。在写导入语句之前，我们应该检查我们是否得到导入错误。通过这种方式，我们尽可能地写出最少的代码行数。</p><p>\3. Spring boot CLI不需要任何构建工具。Spring boot以与Maven和Gradle相同的方式自动抓取spring依赖JAR包。版本是从Spring Boot CLI的版本中提取的。</p><p>\4. Spring boot下载JAR依赖项时，通过记住我们在应用程序编码中使用了哪些spring注解和类。如果我们使用<code>@Controller</code>注解，那么Spring Boot就会下载Spring Web应用程序的JAR依赖项。</p><p>\5. 为了下载第三方依赖的JAR，如thymleaf，spring boot使用<code>@Grab</code>注释groovy功能。</p><p>\6. Spring boot提供<code>spring run</code>命令来运行应用程序，<code>spring test</code>命令来运行spring测试应用程序。</p><p>\7. 我们可以使用spring boot命令行创建可执行的JAR文件。对于应用程序的打包，spring boot提供<code>spring jar</code>命令。</p><p>\8. 使用命令行界面，我们可以使用spring init命令从<code>spring initializer</code>站点创建项目。</p><p>\9. Spring boot为Windows用户提供了使用<code>spring shell</code>命令的集成外壳。</p><p>\10. 使用spring boot CLI时，我们不需要创建<code>spring boot main()</code>方法。它是由spring boot CLI自动提供的。</p><p>在这一篇，我们将安装spring boot CLI，然后我们将创建一个spring boot CLI示例应用程序，并运行它和测试它。</p><p><strong>安装 Spring Boot CLI</strong></p><p>要使用Spring boot CLI，首先我们需要在系统中安装它。有很多方法可以安装Spring boot CLI。</p><ul><li>手动安装</li><li>使用SDKMAN进行安装!</li><li>OSX自制软件的安装</li><li>MacPorts的安装</li><li>命令行完成</li></ul><p>找到Spring boot CLI安装细节的链接。在我的例子中，我将在我的Windows 7操作系统中使用手动安装来安装Spring boot CLI。找到下面的步骤。</p><h5 id="步骤1：使用以下链接下载Spring-boot-CLI"><a href="#步骤1：使用以下链接下载Spring-boot-CLI" class="headerlink" title="步骤1：使用以下链接下载Spring boot CLI"></a>步骤1：使用以下链接下载Spring boot CLI</h5><blockquote><p><a href="http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.4.3.RELEASE/spring-boot-cli-1.4.3.RELEASE-bin.zip">http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.4.3.RELEASE/spring-boot-cli-1.4.3.RELEASE-bin.zip</a></p></blockquote><h5 id="步骤2：解压缩并保存在你系统的某个地方。假设我把它保存在如下位置。"><a href="#步骤2：解压缩并保存在你系统的某个地方。假设我把它保存在如下位置。" class="headerlink" title="步骤2：解压缩并保存在你系统的某个地方。假设我把它保存在如下位置。"></a>步骤2：解压缩并保存在你系统的某个地方。假设我把它保存在如下位置。</h5><ul><li></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\spring-1.4.3.RELEASE</span><br></pre></td></tr></table></figure><p>现在我们需要在我们的系统中设置以下环境变量。</p><ul><li>SPRING_HOME的值为<code>C:\spring-1.4.3.RELEASE</code></li><li>PATH的值为<code>C:\spring-1.4.3.RELEASE\bin</code></li></ul><p>步骤3：现在我们将测试我们的安装。打开命令提示符并键入命令spring，我们将得到以下结果。</p><p><img src="https://s2.loli.net/2022/02/09/HRtLDCqM6dKcEmF.jpg" alt="aedmw-8fld8.jpg"></p><p>查找更多Spring boot CLI命令。</p><ul><li><code>spring help run</code> : 提供支持的命令的详细信息。</li><li><code>spring version</code> : 提供Spring boot CLI的版本。</li></ul><p>现在我们可以开始使用Spring boot CLI了。</p><p><strong>演示项目结构</strong></p><p>找到演示项目结构，我们将使用spring boot CLI和groovy来运行。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring-app</span><br><span class="line">   |</span><br><span class="line">    --message.groovy  </span><br><span class="line">    --hello.groovy </span><br><span class="line">    --tests.groovy</span><br><span class="line">    --templates</span><br><span class="line">         |</span><br><span class="line">          --hello.html</span><br><span class="line">    --static</span><br><span class="line">        |</span><br><span class="line">         --index.html</span><br></pre></td></tr></table></figure><h3 id="用-Spring-Boot-CLI-创建-Hello-World-示例"><a href="#用-Spring-Boot-CLI-创建-Hello-World-示例" class="headerlink" title="用 Spring Boot CLI 创建 Hello World 示例"></a>用 Spring Boot CLI 创建 Hello World 示例</h3><p>我们将使用Groovy创建一个简单的 “Hello World”网络应用。请看下面的代码。</p><p>hello.groovy</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> &#123;</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">    String home() &#123;</span><br><span class="line">        <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用Spring boot CLI和Groovy时，我们可以用最少的代码运行我们的应用程序。在我们的代码中，我们将得到以下结果。</p><p>\1. 默认的导入语句。在大多数情况下，我们不需要导入API。只有在不属于默认导入语句的情况下才可以导入。</p><p>\2. spring boot没有main方法。它将被自动创建。</p><p>为了编译和运行Groovy源代码，Spring boot CLI提供了run命令，我们按以下方式调用。</p><ul><li></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring run hello.groovy </span><br></pre></td></tr></table></figure><p>使用该命令，我们实现了以下几点。</p><ol><li>它下载所有的依赖性JAR。依赖性JAR的版本由我们所使用的Spring boot CLI的版本决定。下载JAR只在第一次时进行。</li><li>依赖性JAR是由代码中使用的类和注解定义的。由于我们使用的是<code>@RestController</code>，所以会下载与Spring MVC和嵌入式Tomcat相关的JAR。</li><li>现在它编译代码并在默认端口8080上启动嵌入式Tomcat服务器。</li></ol><p>找到打印界面。</p><p><img src="https://s2.loli.net/2022/02/09/Rz4hjLC8u9kSgxI.jpg" alt="a9vxd-efgnd.jpg"></p><p>通过URL <code>http://localhost:8080/home</code> 来访问该应用程序。</p><p><img src="https://s2.loli.net/2022/02/09/S9bMJ7UWOdTvs42.jpg" alt="ak53c-591dq.jpg"></p><p>如果我们想改变默认端口，那么我们需要用<code>server.port</code>运行命令，如下所示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring run hello.groovy -- --server.port=8484 </span><br></pre></td></tr></table></figure><p>我们需要注意，我们将使用分隔符–与spring命令参数<code>--server.port</code>一起。现在，嵌入式Tomcat将以8484端口启动，为了运行应用程序，我们需要使用<code>http://localhost:8484/home</code>来访问。</p><p>如果我们有多个groovy文件，并且要一起运行所有这些groovy文件，我们可以使用以下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring run *.groovy </span><br></pre></td></tr></table></figure><h3 id="使用-Grab-注释"><a href="#使用-Grab-注释" class="headerlink" title="使用 @Grab 注释"></a>使用 @Grab 注释</h3><p>Groovy提供了@Grab注解来解决JAR的依赖性。Spring boot也支持@Grab注解，只解决第三方的依赖。根据Spring注解和应用程序中使用的类，Spring的依赖性被自动抓取。</p><p>它下载JAR的方式与Maven和Gradle相同，无需使用任何构建工具。我们使用@Grab注解来下载第三方依赖，如下所示。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Grab</span>(<span class="string">&#x27;spring-boot-starter-thymeleaf&#x27;</span>)<span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> &#123;</span>&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将看到我们只需要传递artifact id。Group id 和 version将从spring boot的默认依赖元数据中获取。现在找到这个例子中使用的groovy和HTML文件。</p><p>message.groovy</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Grab</span>(<span class="string">&#x27;spring-boot-starter-thymeleaf&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> &#123;</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">&quot;/msg&quot;</span>)</span><br><span class="line"> String getMsg(Model model) &#123;</span><br><span class="line">     String msg = <span class="string">&quot;Welcome to Everyone!&quot;</span>;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>templates/hello.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Boot CLI Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Message: &#x27; + $&#123;message&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>static/index.html</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Boot CLI Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Click to get <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/msg&quot;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>要运行这个例子，在项目的根目录下用命令提示符运行以下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring run *.groovy </span><br></pre></td></tr></table></figure><p>现在访问 <code>http://localhost:8080/</code></p><p>Spring boot只需要@Grab注解来解决第三方JAR，例如spring-boot-starter-thymeleaf，freemarker等。Spring boot会根据需要自动抓取spring JAR。</p><p>例如，如果我们使用以下注解和类，那么相关的JAR依赖将被自动下载。</p><ol><li>@Controller @RestController @EnableWebMvc : 在这种情况下，Spring MVC和嵌入式Tomcat将被下载。</li><li>@EnableWebSecurity : Spring安全相关的JAR将被下载。</li><li>@EnableJms: JMS应用程序相关的JAR将被下载。</li><li>@Test : 将会下载Spring测试应用相关的JAR。</li></ol><p>具体请查看链接中的Deduced “grab” Dependencies部分</p><p><strong>Spring Boot CLI 测试应用程序</strong></p><p>Spring boot CLI提供了test命令，我们可以用它来测试我们的spring boot应用程序。找到我们例子中使用的groovy类来测试hello.groovy。</p><p>tests.groovy</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> &#123;</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> HelloAppTest() &#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;Hello World!&quot;</span>, <span class="keyword">new</span> HelloController().home())</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>要运行测试应用程序，请使用以下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring test hello.groovy tests.groovy </span><br></pre></td></tr></table></figure><p>上述命令的说明如下。</p><ul><li><code>spring test</code>：Spring boot CLI命令，用于测试应用程序。</li><li><code>hello.groovy</code>：需要测试的应用程序文件。</li><li><code>tests.groovy</code>：测试文件，用于测试应用程序文件。</li></ul><p>运行该命令后，我们得到的结果如下。</p><p><img src="https://s2.loli.net/2022/02/09/nuOZAvQIkNRlryg.jpg" alt="a1mom-9ejfd.jpg"></p><h3 id="使用-Spring-Boot-CLI-打包应用程序"><a href="#使用-Spring-Boot-CLI-打包应用程序" class="headerlink" title="使用 Spring Boot CLI 打包应用程序"></a>使用 Spring Boot CLI 打包应用程序</h3><p>Spring boot CLI提供了jar命令来打包我们的应用程序。我们可以按以下方式使用它。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring jar spring-app.jar *.groovy </span><br></pre></td></tr></table></figure><p>这将创建两个JAR。</p><ul><li><code>spring-app.jar</code> : 这是可执行的JAR。</li><li><code>spring-app.jar.original</code> : 这是原JAR。</li></ul><p>可执行的jar文件的运行方式如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar spring-app.jar </span><br></pre></td></tr></table></figure><p>找到打印界面。</p><p><img src="https://s2.loli.net/2022/02/09/J5INgGEwk8T46xe.jpg" alt="avoib-ldo6w.jpg"></p><p>在打包应用程序时，spring boot默认包括以下目录。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public/**, resources/**, static/**, templates/**, META-INF/**</span><br></pre></td></tr></table></figure><p>而默认的排除目录是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repository/**, build/**, target/**, **/*.jar, **/*.groovy </span><br></pre></td></tr></table></figure><p>使用<code>--include</code>，我们可以将默认排除目录添加到打包的目录中。使用<code>--exclude</code>，我们可以删除打包的目录。有关更多详细信息，我们可以按如下方式运行help命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring help jar </span><br></pre></td></tr></table></figure><h3 id="使用-Spring-Boot-CLI-创建一个新项目"><a href="#使用-Spring-Boot-CLI-创建一个新项目" class="headerlink" title="使用 Spring Boot CLI 创建一个新项目"></a>使用 Spring Boot CLI 创建一个新项目</h3><p>使用init命令，Spring boot CLI可以用maven作为默认的构建工具创建一个新项目，该工具使用<code>https://start.spring.io</code>。假设我们想用thymleaf创建一个Web项目，那么我们将运行如下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring init --dependencies=web,thymeleaf my-app.zip </span><br></pre></td></tr></table></figure><p>在pom.xml中，web,thymeleaf的依赖关系将配置为以下spring boot启动器。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring-boot-starter-web</span><br><span class="line">spring-boot-starter-thymeleaf </span><br></pre></td></tr></table></figure><p>my-app.zip文件将被下载到我们运行命令的目录中。</p><p><img src="https://s2.loli.net/2022/02/09/9RDew3hKzCEmdAn.jpg" alt="anve7-b7zej.jpg"></p><p>如果我们想使用Gradle构建工具，用任何特定的java版本构建WAR文件，那么我们可以运行如下命令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring init --build=gradle --java-version=1.8 --dependencies=web,thymeleaf --packaging=war my-app.zip </span><br></pre></td></tr></table></figure><h3 id="使用嵌入式-Shell"><a href="#使用嵌入式-Shell" class="headerlink" title="使用嵌入式 Shell"></a>使用嵌入式 Shell</h3><p>Spring boot有BASH和Zsh shells的命令行完成脚本。</p><p>如果我们使用WINDOWS，Spring Boot提供shell命令来启动一个集成shell。如果使用WINDOWS，那么使用以下命令启动集成shell。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring shell </span><br></pre></td></tr></table></figure><p>现在我们可以直接运行命令而不使用spring关键字，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ version</span><br><span class="line">$ test hello.groovy tests.groovy</span><br><span class="line">$ run hello.groovy </span><br></pre></td></tr></table></figure><p>找到打印界面。</p><p><img src="https://s2.loli.net/2022/02/09/mHVCBOK3o6Leabt.jpg" alt="aegkp-3zo8h.jpg"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html">http://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/cli-using-the-cli.html">https://docs.spring.io/spring-boot/docs/current/reference/html/cli-using-the-cli.html</a></p><p><a href="https://www.concretepage.com/spring-boot/spring-boot-cli-example">https://www.concretepage.com/spring-boot/spring-boot-cli-example</a></p><p><strong>源码下载</strong></p><p><a href="https://www.concretepage.com/spring-boot/download/spring-boot-cli-example.zip">https://www.concretepage.com/spring-boot/download/spring-boot-cli-example.zip</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 实现各种参数校验</title>
      <link href="/2022/02/08/SpringBoot-%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/2022/02/08/SpringBoot-%E5%AE%9E%E7%8E%B0%E5%90%84%E7%A7%8D%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>之前也写过一篇关于Spring Validation使用的文章，不过自我感觉还是浮于表面，本次打算彻底搞懂Spring Validation。本文会详细介绍Spring Validation各种场景下的最佳实践及其实现原理，死磕到底！</p><blockquote><p>项目源码：<a href="https://github.com/chentianming11/spring-validation">https://github.com/chentianming11/spring-validation</a></p></blockquote><h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1. 简单使用"></a>1. 简单使用</h2><p>Java API规范(JSR303)定义了Bean校验的标准validation-api，但没有提供实现。hibernate validation是对这个规范的实现，并增加了校验注解如@Email、@Length等。</p><p>Spring Validation是对hibernate validation的二次封装，用于支持spring mvc参数自动校验。接下来，我们以spring-boot项目为例，介绍Spring Validation的使用。</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>如果spring-boot版本小于2.3.x，spring-boot-starter-web会自动传入hibernate-validator依赖。如果spring-boot版本大于2.3.x，则需要手动引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于web服务来说，为防止非法参数对业务造成影响，在Controller层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：</p><ul><li>POST、PUT请求，使用requestBody传递参数；</li><li>GET请求，使用requestParam/PathVariable传递参数。</li></ul><p>下面我们简单介绍下requestBody和requestParam/PathVariable的参数校验实战！</p><h3 id="requestBody参数校验"><a href="#requestBody参数校验" class="headerlink" title="requestBody参数校验"></a>requestBody参数校验</h3><p>POST、PUT请求一般会使用requestBody传递参数，这种情况下，后端使用DTO对象进行接收。只要给DTO对象加上@Validated注解就能实现自动参数校验。比如，有一个保存User的接口，要求userName长度是2-10，account和password字段长度是6-20。</p><p>如果校验失败，会抛出MethodArgumentNotValidException异常，Spring默认会将其转为400（Bad Request）请求。</p><blockquote><p>DTO表示数据传输对象（Data Transfer Object），用于服务器和客户端之间交互传输使用的。在spring-web项目中可以表示用于接收请求参数的Bean对象。</p></blockquote><p>在DTO字段上声明约束注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法参数上声明校验注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，使用@Valid和@Validated都可以。</p><h3 id="requestParam-PathVariable参数校验"><a href="#requestParam-PathVariable参数校验" class="headerlink" title="requestParam/PathVariable参数校验"></a>requestParam/PathVariable参数校验</h3><p>GET请求一般会使用requestParam/PathVariable传参。如果参数比较多(比如超过6个)，还是推荐使用DTO对象接收。</p><p>否则，推荐将一个个参数平铺到方法入参中。在这种情况下，必须在Controller类上标注@Validated注解，并在入参上声明约束注解(如@Min等)。如果校验失败，会抛出ConstraintViolationException异常。</p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路径变量</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">detail</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> <span class="meta">@Min(10000000000000000L)</span> Long userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">        UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">        userDTO.setUserId(userId);</span><br><span class="line">        userDTO.setAccount(<span class="string">&quot;11111111111111111&quot;</span>);</span><br><span class="line">        userDTO.setUserName(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">        userDTO.setAccount(<span class="string">&quot;11111111111111111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询参数</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;getByAccount&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getByAccount</span><span class="params">(<span class="meta">@Length(min = 6, max = 20)</span> <span class="meta">@NotNull</span> String  account)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">        UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">        userDTO.setUserId(<span class="number">10000000000000003L</span>);</span><br><span class="line">        userDTO.setAccount(account);</span><br><span class="line">        userDTO.setUserName(<span class="string">&quot;xixi&quot;</span>);</span><br><span class="line">        userDTO.setAccount(<span class="string">&quot;11111111111111111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>前面说过，如果校验失败，会抛出MethodArgumentNotValidException或者ConstraintViolationException异常。在实际项目开发中，通常会用统一异常处理来返回一个更友好的提示。</p><p>比如我们系统要求无论发送什么异常，http的状态码必须返回200，由业务码去区分系统的异常情况。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">        BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;校验失败:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            sb.append(fieldError.getField()).append(<span class="string">&quot;：&quot;</span>).append(fieldError.getDefaultMessage()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String msg = sb.toString();</span><br><span class="line">       <span class="keyword">return</span> Result.fail(BusinessCode.参数校验失败, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(&#123;ConstraintViolationException.class&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(BusinessCode.参数校验失败, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-进阶使用"><a href="#2-进阶使用" class="headerlink" title="2. 进阶使用"></a>2. 进阶使用</h2><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>在实际项目中，可能多个方法需要使用同一个DTO类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在DTO类的字段上加约束注解无法解决这个问题。因此，spring-validation支持了分组校验的功能，专门用来解决这类问题。</p><p>还是上面的例子，比如保存User的时候，UserId是可空的，但是更新User的时候，UserId的值必须&gt;=10000000000000000L；其它字段的校验规则在两种情况下一样。这个时候使用分组校验的代码示例如下：</p><p>约束注解上声明适用的分组信息groups</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 10000000000000000L, groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Save</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Validated注解上指定校验分组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Save.class)</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Update.class)</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h3><p>前面的示例中，DTO类里面的字段都是基本数据类型和String类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用嵌套校验。</p><p>比如，上面保存User信息的时候同时还带有Job信息。需要注意的是，此时DTO类的对应字段必须标记@Valid注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(value = 10000000000000000L, groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Length(min = 6, max = 20, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> Job job;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Min(value = 1, groups = Update.class)</span></span><br><span class="line">        <span class="keyword">private</span> Long jobId;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String jobName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull(groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="meta">@Length(min = 2, max = 10, groups = &#123;Save.class, Update.class&#125;)</span></span><br><span class="line">        <span class="keyword">private</span> String position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Save</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套校验可以结合分组校验一起使用。还有就是嵌套集合校验会对集合里面的每一项都进行校验，例如<code>List&lt;Job&gt;</code>字段会对这个list里面的每一个Job对象都进行校验</p><h3 id="集合校验"><a href="#集合校验" class="headerlink" title="集合校验"></a>集合校验</h3><p>如果请求体直接传递了json数组给后台，并希望对数组中的每一项都进行参数校验。此时，如果我们直接使用java.util.Collection下的list或者set来接收数据，参数校验并不会生效！我们可以使用自定义list集合来接收参数：</p><p>包装List类型，并声明@Valid注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delegate</span> <span class="comment">// @Delegate是lombok注解</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 一定要加@Valid注解</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要记得重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Delegate注解受lombok版本限制，1.18.6以上版本可支持。如果校验不通过，会抛出NotReadablePropertyException，同样可以使用统一异常进行处理。</p><p>比如，我们需要一次性保存多个User对象，Controller层的方法可以这么写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/saveList&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveList</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(UserDTO.Save.class)</span> ValidationList&lt;UserDTO&gt; userList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h3><p>业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。</p><p>自定义spring validation非常简单，假设我们自定义加密id（由数字或者a-f的字母组成，32-256长度）校验，主要分为两步：</p><p>自定义约束注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;EncryptIdValidator.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EncryptId &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认错误消息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;加密id格式错误&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载</span></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现ConstraintValidator接口编写约束校验器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptIdValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">EncryptId</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN = Pattern.compile(<span class="string">&quot;^[a-f\\d]&#123;32,256&#125;$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不为null才进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Matcher matcher = PATTERN.matcher(value);</span><br><span class="line">            <span class="keyword">return</span> matcher.find();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以使用@EncryptId进行参数校验了！</p><h3 id="编程式校验"><a href="#编程式校验" class="headerlink" title="编程式校验"></a>编程式校验</h3><p>上面的示例都是基于注解来实现自动校验的，在某些情况下，我们可能希望以编程方式调用验证。这个时候可以注入javax.validation.Validator对象，然后再调用其api。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> javax.validation.Validator globalValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编程式校验</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/saveWithCodingValidate&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveWithCodingValidate</span><span class="params">(<span class="meta">@RequestBody</span> UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;UserDTO&gt;&gt; validate = globalValidator.validate(userDTO, UserDTO.Save.class);</span><br><span class="line">    <span class="comment">// 如果校验通过，validate为空；否则，validate包含未校验通过项</span></span><br><span class="line">    <span class="keyword">if</span> (validate.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;UserDTO&gt; userDTOConstraintViolation : validate) &#123;</span><br><span class="line">            <span class="comment">// 校验失败，做其它逻辑</span></span><br><span class="line">            System.out.println(userDTOConstraintViolation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速失败-Fail-Fast"><a href="#快速失败-Fail-Fast" class="headerlink" title="快速失败(Fail Fast)"></a>快速失败(Fail Fast)</h3><p>Spring Validation默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启Fali Fast模式，一旦校验失败就立即返回。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Validator <span class="title">validator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class)</span><br><span class="line">            .configure()</span><br><span class="line">            <span class="comment">// 快速失败模式</span></span><br><span class="line">            .failFast(<span class="keyword">true</span>)</span><br><span class="line">            .buildValidatorFactory();</span><br><span class="line">    <span class="keyword">return</span> validatorFactory.getValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Valid和-Validated区别"><a href="#Valid和-Validated区别" class="headerlink" title="@Valid和@Validated区别"></a>@Valid和@Validated区别</h3><p>如图</br><br><img src="https://s2.loli.net/2022/02/08/RqmnVMUwPefiLbO.jpg" alt="646.jpg"></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><h3 id="requestBody参数校验实现原理"><a href="#requestBody参数校验实现原理" class="headerlink" title="requestBody参数校验实现原理"></a>requestBody参数校验实现原理</h3><p>在spring-mvc中，RequestResponseBodyMethodProcessor是用于解析@RequestBody标注的参数以及处理@ResponseBody标注方法的返回值的。显然，执行参数校验的逻辑肯定就在解析参数的方法resolveArgument()中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        parameter = parameter.nestedIfOptional();</span><br><span class="line">        <span class="comment">//将请求数据封装到DTO对象中</span></span><br><span class="line">        Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">        String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">            <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 执行数据校验</span></span><br><span class="line">                validateIfApplicable(binder, parameter);</span><br><span class="line">                <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，resolveArgument()调用了validateIfApplicable()进行参数校验。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取参数注解，比如@RequestBody、@Valid、@Validated</span></span><br><span class="line">    Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">        <span class="comment">// 先尝试获取@Validated注解</span></span><br><span class="line">        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);</span><br><span class="line">        <span class="comment">//如果直接标注了@Validated，那么直接开启校验。</span></span><br><span class="line">        <span class="comment">//如果没有，那么判断参数前是否有Valid起头的注解。</span></span><br><span class="line">        <span class="keyword">if</span> (validatedAnn != <span class="keyword">null</span> || ann.annotationType().getSimpleName().startsWith(<span class="string">&quot;Valid&quot;</span>)) &#123;</span><br><span class="line">            Object hints = (validatedAnn != <span class="keyword">null</span> ? validatedAnn.value() : AnnotationUtils.getValue(ann));</span><br><span class="line">            Object[] validationHints = (hints <span class="keyword">instanceof</span> Object[] ? (Object[]) hints : <span class="keyword">new</span> Object[] &#123;hints&#125;);</span><br><span class="line">            <span class="comment">//执行校验</span></span><br><span class="line">            binder.validate(validationHints);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，大家应该能明白为什么这种场景下@Validated、@Valid两个注解可以混用。我们接下来继续看WebDataBinder.validate()实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors, Object... validationHints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.targetValidator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processConstraintViolations(</span><br><span class="line">            <span class="comment">//此处调用Hibernate Validator执行真正的校验</span></span><br><span class="line">            <span class="keyword">this</span>.targetValidator.validate(target, asValidationGroups(validationHints)), errors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终发现底层最终还是调用了Hibernate Validator进行真正的校验处理。</p><h3 id="方法级别的参数校验实现原理"><a href="#方法级别的参数校验实现原理" class="headerlink" title="方法级别的参数校验实现原理"></a>方法级别的参数校验实现原理</h3><p>上面提到的将参数一个个平铺到方法参数中，然后在每个参数前面声明约束注解的校验方式，就是方法级别的参数校验。</p><p>实际上，这种方式可用于任何Spring Bean的方法上，比如Controller/Service等。其底层实现原理就是AOP，具体来说是通过MethodValidationPostProcessor动态注册AOP切面，然后使用MethodValidationInterceptor对切点方法织入增强。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationPostProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryAwareAdvisingPostProcessorimplements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为所有`@Validated`标注的Bean创建切面</span></span><br><span class="line">        Pointcut pointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">this</span>.validatedAnnotationType, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//创建Advisor进行增强</span></span><br><span class="line">        <span class="keyword">this</span>.advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(<span class="keyword">this</span>.validator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Advice，本质就是一个方法拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Advice <span class="title">createMethodValidationAdvice</span><span class="params">(<span class="meta">@Nullable</span> Validator validator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (validator != <span class="keyword">null</span> ? <span class="keyword">new</span> MethodValidationInterceptor(validator) : <span class="keyword">new</span> MethodValidationInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看一下MethodValidationInterceptor：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//无需增强的方法，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isFactoryBeanMetadataMethod(invocation.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取分组信息</span></span><br><span class="line">        Class&lt;?&gt;[] groups = determineValidationGroups(invocation);</span><br><span class="line">        ExecutableValidator execVal = <span class="keyword">this</span>.validator.forExecutables();</span><br><span class="line">        Method methodToValidate = invocation.getMethod();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//方法入参校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">            result = execVal.validateParameters(</span><br><span class="line">                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有异常直接抛出</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//真正的方法调用</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line">        <span class="comment">//对返回值做校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);</span><br><span class="line">        <span class="comment">//有异常直接抛出</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，不管是requestBody参数校验还是方法级别的校验，最终都是调用Hibernate Validator执行校验，Spring Validation只是做了一层封装。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图解i++和++i的区别</title>
      <link href="/2022/02/08/%E5%9B%BE%E8%A7%A3i++%E5%92%8C++i%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/08/%E5%9B%BE%E8%A7%A3i++%E5%92%8C++i%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="先看一段代码："><a href="#先看一段代码：" class="headerlink" title="先看一段代码："></a>先看一段代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = i++;</span><br><span class="line">sout(<span class="string">&quot;a的值是:&quot;</span>+i);</span><br><span class="line">sout(<span class="string">&quot;i的值是:&quot;</span>+i);</span><br></pre></td></tr></table></figure><p>最终的编译之后的核心字节码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L0</span><br><span class="line"> BITPUSH <span class="number">0</span>  <span class="comment">//将常量0压入操作栈</span></span><br><span class="line"> ISTORE_1  <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_1中</span></span><br><span class="line"></span><br><span class="line">L1</span><br><span class="line"> ILOAD_1   <span class="comment">//从局部变量表的第一个slot槽中，取出该值，压入操作栈顶</span></span><br><span class="line"> IINC <span class="number">0</span>,<span class="number">1</span>    <span class="comment">//直接将slot槽中的值自增（+1）操作，注意此时是与当前栈无关的 </span></span><br><span class="line"> ISTORE_2   <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_2中</span></span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"> ILOAD_2    <span class="comment">//从局部变量表的第二个slot槽中，取出该值，压入操作栈顶</span></span><br><span class="line">  IRETURN  <span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><p>这里有两个注意点:</p><ul><li><code>IINC</code> 的自增操作,并未影响当前的栈顶元素,并且 slot_1 中的元素自增完成后,已经由0变成了1</li><li><code>ISTORE_2</code> 弹出的栈顶元素值依旧是0,并未改变</li></ul><p>最终的输出的结果为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a的值是: <span class="number">0</span> </span><br><span class="line">i的值是: <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我这里画了一个图来帮助大家理解</br><br><img src="https://s2.loli.net/2022/02/08/G8akw4rI1OLYoW5.jpg" alt="640.jpg"><br><img src="https://s2.loli.net/2022/02/08/sBjAKxuQwJkYno5.jpg" alt="641.jpg"><br><img src="https://s2.loli.net/2022/02/08/IGDwFnWOciTkjaA.jpg" alt="642.jpg"><br><img src="https://s2.loli.net/2022/02/08/ceWxiqp6BR1bQwP.jpg" alt="643.jpg"><br><img src="https://s2.loli.net/2022/02/08/QANFcGlL2KspJif.jpg" alt="644.jpg"><br><img src="https://s2.loli.net/2022/02/08/stnOl6pqVJhY4ig.jpg" alt="645.jpg"> </p><p>再来看看++i</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = ++i;</span><br><span class="line">sout(<span class="string">&quot;a的值是:&quot;</span>+i);</span><br><span class="line">sout(<span class="string">&quot;i的值是:&quot;</span>+i);</span><br></pre></td></tr></table></figure><p>对于++i 来说,对应的字节码如下，先自增再入栈，那么结果就很清晰了</p><p>最终的核心编译之后的字节码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L0</span><br><span class="line"> BITPUSH <span class="number">0</span>  <span class="comment">//将常量0压入操作栈</span></span><br><span class="line"> ISTORE_1  <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_1中</span></span><br><span class="line"></span><br><span class="line">L1</span><br><span class="line"> IINC <span class="number">0</span>,<span class="number">1</span>    <span class="comment">//直接将slot槽中的值自增（+1）操作</span></span><br><span class="line"> ILOAD_1   <span class="comment">//从局部变量表的第一个slot槽中，取出该值(该值此时已经自增过了)，压入操作栈顶</span></span><br><span class="line"> ISTORE_2   <span class="comment">//将当前栈顶元素,弹出并保存到局部变量表的slot_2中</span></span><br><span class="line"></span><br><span class="line">L3</span><br><span class="line"> ILOAD_2    <span class="comment">//从局部变量表的第二个slot槽中，取出该值，压入操作栈顶</span></span><br><span class="line"> IRETURN  <span class="comment">//返回栈顶元素</span></span><br></pre></td></tr></table></figure><p>最终的输出的结果为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a的值是: <span class="number">1</span> </span><br><span class="line">i的值是: <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>i++</code> 和 ++i 在理论上的区别是 ：</p><ul><li><code>i++</code>：是先把i拿出来使用，然后再+1；</li><li><code>++i</code> ：是先把i+1，然后再拿出来使用；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>idea的这些功能你都用会了吗？</title>
      <link href="/2022/02/05/idea%E7%9A%84%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%A0%E9%83%BD%E7%94%A8%E4%BC%9A%E4%BA%86%E5%90%97/"/>
      <url>/2022/02/05/idea%E7%9A%84%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E4%BD%A0%E9%83%BD%E7%94%A8%E4%BC%9A%E4%BA%86%E5%90%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>最近正好也没什么可忙的，就回过头来鼓捣过去的知识点，到Servlet部分时，以前学习的时候硬是把从上到下的继承关系和接口实现记得乱七八糟。</p><p>这次利用了 IDEA 的 diagram，结果一目了然，也是好用到炸裂，就此分享。</p><h2 id="查看图形形式的继承链"><a href="#查看图形形式的继承链" class="headerlink" title="查看图形形式的继承链"></a><strong>查看图形形式的继承链</strong></h2><p>在你想查看的类的标签页内，点击右键，选择 Diagrams，其中有 show 和 show … Popup，只是前者新建在标签页内，后者以浮窗的形式展示：</p><p><img src="https://s2.loli.net/2022/02/05/8mYAcuTbraZvDXM.png"></p><p>实际上，你也可以从左边的项目目录树中，对你想查看的类点击右键，同样选择Diagrams，效果是一样的：</p><p><img src="https://s2.loli.net/2022/02/05/5ce8mZyWRqsKBfG.png"></p><p>然后你就会得到如下图所示的继承关系图形，以自定义的Servlet为例：</p><p><img src="https://s2.loli.net/2022/02/05/iIMkEoUy65aSBdN.png"></p><h2 id="优化继承链图形，想我所想"><a href="#优化继承链图形，想我所想" class="headerlink" title="优化继承链图形，想我所想"></a><strong>优化继承链图形，想我所想</strong></h2><h3 id="去掉不关心的类"><a href="#去掉不关心的类" class="headerlink" title="去掉不关心的类"></a><strong>去掉不关心的类</strong></h3><p>得到的继承关系图形，有些并不是我们想去了解的，比如上图的Object和Serializable，我们只想关心Servlet重要的那几个继承关系，怎么办？</p><p>简单，删掉。点击选择你想要删除的类，然后直接使用键盘上的delete键就行了。清理其他类的关系后图形如下：</p><p><img src="https://s2.loli.net/2022/02/05/YBestXDa2hTpoIz.png"></p><h3 id="展示类的详细信息"><a href="#展示类的详细信息" class="headerlink" title="展示类的详细信息"></a><strong>展示类的详细信息</strong></h3><p>有人说，诶，这怎么够呢，那继承下来的那些方法我也想看啊？简单，IDEA通通满足你。</p><p>在页面点击右键，选择 show categories，根据需要可以展开类中的属性、方法、构造方法等等。当然，第二种方法也可以直接使用上面的工具栏：</p><p><img src="https://s2.loli.net/2022/02/05/ORxvbnC63gDyFTc.png"></p><p>然后你就会得到：</p><p><img src="https://s2.loli.net/2022/02/05/yksvfK1jJE6L3Sw.png"></p><p>什么，方法里你还想筛选，比如说想看protected权限及以上范围的？简单，右键选择 Change Visibility Level，根据需要调整即可。</p><p><img src="https://s2.loli.net/2022/02/05/4nJ6yDRT9brl1vX.png"></p><p>什么，你嫌图形太小你看不清楚？IDEA也可以满足你，按住键盘的Alt，竟然出现了放大镜，惊不惊喜，意不意外？</p><p><img src="https://s2.loli.net/2022/02/05/gdkwA19ePfyt4ID.png"></p><h3 id="加入其他类到关系中来"><a href="#加入其他类到关系中来" class="headerlink" title="加入其他类到关系中来"></a><strong>加入其他类到关系中来</strong></h3><p>当我们还需要查看其他类和当前类是否有继承上的关系的时候，我们可以选择加其加入到当前的继承关系图形中来。</p><p>在页面点击右键，选择 Add Class to Diagram，然后输入你想加入的类就可以了：</p><p><img src="https://s2.loli.net/2022/02/05/vRPVdYz5wQBZ4X2.png"></p><p>例如我们添加了一个Student类，如下图所示。好吧，并没有任何箭头，看来它和当前这几个类以及接口并没有发生什么不可描述的关系：</p><p><img src="https://s2.loli.net/2022/02/05/u37kXepHIdNMmKz.png"></p><h3 id="查看具体代码"><a href="#查看具体代码" class="headerlink" title="查看具体代码"></a><strong>查看具体代码</strong></h3><p>如果你想查看某个类中，比如某个方法的具体源码，当然，不可能给你展现在图形上了，不然屏幕还不得撑炸？</p><p>但是可以利用图形，或者配合IDEA的structure方便快捷地进入某个类的源码进行查看。</p><p>双击某个类后，你就可以在其下的方法列表中游走，对于你想查看的方法，选中后点击右键，选择 Jump to Source：</p><p><img src="https://s2.loli.net/2022/02/05/RwFvDNzMlk5sjaL.png"></p><p><img src="https://s2.loli.net/2022/02/05/y5vTQGe9wOHVm7p.png"></p><p>在进入某个类后，如果还想快速地查看该类的其他方法，还可以利用IDEA提供的structure功能：</p><p><img src="https://s2.loli.net/2022/02/05/hKFIHs7ngdYjcu5.png"></p><p>选择左侧栏的structure之后，如上图左侧会展示该类中的所有方法，点击哪个方法，页面内容就会跳转到该方法部分去。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>用上面提到的的IDEA这些功能，学习和查看类关系，了解诸如主流框架源码之类的东西，可以说是非常舒服了。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
